// Enable/Disable Debug Mode
integer LINK_INTERFACE_DEBUG = 17000; // Send message too LINK_INTERFACE_ENABLE_DEBUG or LINK_INTERFACE_DISABLE_DEBUG based on toggle state

// Add Menus To Interface API
integer LINK_INTERFACE_ADD = 15002;

// Cancel Dialog Request
integer LINK_INTERFACE_CANCEL = 14012;

// Cancel Is Hit For LINK_INTERFACE_NUMERIC
integer LINK_INTERFACE_CANCELLED = 14006; // Message sent from LINK_INTERFACE_CANCEL to link message to be used in other scripts.

// Clear Dialog Request
integer LINK_INTERFACE_CLEAR = 15001;

// Display Dialog Interface
integer LINK_INTERFACE_DIALOG = 14001;

// Notify Dialog Type
integer LINK_INTERFACE_NOTIFY = 14004;

// Dialog Not Found
integer LINK_INTERFACE_NOT_FOUND = 15010;

// Display Numeric Interface
integer LINK_INTERFACE_NUMERIC = 14005;

// Reshow Last Dialog Displayed
integer LINK_INTERFACE_RESHOW = 14011;

// A Button Is Hit, Or OK Is Hit For LINK_INTERFACE_NUMERIC
integer LINK_INTERFACE_RESPONSE = 14002;

// Display Dialog
integer LINK_INTERFACE_SHOW = 15003;

// Play Sound When Dialog Button Touched
integer LINK_INTERFACE_SOUND = 15021;

// Display Textbox Interface
integer LINK_INTERFACE_TEXTBOX = 14007;

// No Button Is Hit, Or Ignore Is Hit
integer LINK_INTERFACE_TIMEOUT = 14003;

// ==============================================================
// You may not need to change anything below this section, but
// feel free to look through the code if you would like to modify
// the basic functionality.
// ==============================================================

// Define A Channel For Listening

integer PRIMITIZER_CHANNEL;

// Define A Channel Handle To Remove PRIMITIZER_CHANNEL
integer PRIMITIZER_HANDLE;

// Define API Seperator For Parsing String Data
string PRIMITIZER_SEPERATOR = "||";

/*
Scenes
Gloves
Options
Functions
Help

*/
// Define A List Containing All The Possible Menu Buttons


list SYSTEM_MENU_BUTTONS = ["Options","Functions","Help"];
list SYSTEM_MENU_COMMANDS = [];
list SYSTEM_MENU_ID_NAMES = [];
list SYSTEM_MENU_RETURNS = ["MENU_OPTIONS", "MENU_FUNCTIONS", "MENU_HELP"];
// returns
// commands


/* Help Menu */
list HELP_MENU_BUTTONS = ["Updates","Read Me","Contact", "Tutorial", "About", "Website"];
list HELP_MENU_COMMANDS = [];
list HELP_MENU_ID_NAMES = [];
list HELP_MENU_RETURNS = ["MENU_OPTIONS","MENU_FUNCTIONS","MENU_HELP"];

/*
What would you like to do?

* Updates
* Read Me
* Contact
* Tutorial
* About
* Website
*/
/* Tutorial */
list TUTORIAL_MENU_BUTTONS = ["Yes", "No", "Back"];
list TUTORIAL_MENU_COMMANDS = [];
list TUTORIAL_MENU_ID_NAMES = [];
list TUTORIAL_MENU_RETURNS = ["MENU_OPTIONS","MENU_FUNCTIONS","MENU_HELP"];

/*
Would You Like To Enable Tutorial Tips?

* Yes
* No
* Back
*/
/*

*/

// The Maximum Number Of Buttons That Can Be Displayed In The Dialog At One Time
integer DIALOG_MAX_BUTTONS = 12;

// The Number Of Menu Items Available.
integer DIALOG_ITEMS_COUNT = 0;

// Define Cycle Number To Keep Track Of Which DIALOG_ITEMS_SUBLIST To Display
integer DIALOG_CYCLE_INDEX = 0;

// Message To Be Shown With The Dialog
string DIALOG_MENU_MESSAGE = "Pick a Number";

// define tokens for the Prev and Next operations
string BUTTON_BACK = "◄ Back";
string BUTTON_NEXT = "Next ►";

/*
[07:48] Object: SYSTEM_MENU_BUTTONS:SUB_3_1#SUB_3_2#SUB_3_3#MAIN MENU#SUB_2#BUTTON_X
[07:48] Object: DIALOG_MENU_RETURNS:3.1#3.2#3.3#MENU_MainMenu#MENU_SubMenu2#EXIT
[07:48] Object: DIALOG_MENU_ID_NAMES:MainMenu#SubMenu1#SubMenu2#SubMenu3
[07:48] Object: DIALOG_MENU_COMMANDS:Main Menu Dialog Message||30||BUTTON_1||MENU_SubMenu1||BUTTON_2||MENU_SubMenu2||BUTTON_3||MENU_SubMenu3||Debug||Debug||Textbox||Textbox||Numberbox||Numeric||BUTTON_X||EXIT#Sub Menu 1 Dialog Message||30||SUB_1_1||1.1||SUB_1_2||1.2||SUB_1_3||1.3||MAIN MENU||MENU_MainMenu||SUB_3||MENU_SubMenu3||BUTTON_X||EXIT#Sub Menu 2 Dialog Message||30||SUB_2_1||2.1||SUB_2_2||2.2||SUB_2_3||2.3||MAIN MENU||MENU_MainMenu||SUB_1||MENU_SubMenu1||BUTTON_X||EXIT#Sub Menu 3 Dialog Message||30||SUB_3_1||3.1||SUB_3_2||3.2||SUB_3_3||3.3||MAIN MENU||MENU_MainMenu||SUB_2||MENU_SubMenu2||BUTTON_X||EXIT

*/

//Inventory
list inventory(integer type)
{
    list inventory = [];
    integer index;
    integer count = llGetInventoryNumber(type);
    string  inventory_name;
    for(index=0; index<count; index++)
    {
        inventory_name = llGetInventoryName(type, index);
        inventory += [inventory_name];
    }
    return inventory;
}

list sort(list buttons)
{
    return llList2List(buttons, -3, -1) + llList2List(buttons, -6, -4) +
        llList2List(buttons, -9, -7) + llList2List(buttons, -12, -10);
}

// figure out which sublist cycle should be displayed
//
// items can be any list that has a bunch of items in it
// direction can be BUTTON_BACK, BUTTON_NEXT, or a blank String
list pagination(list items, string direction)
{
    // the sublist that will be generated by the next few operations
    list sublist = [];

    // calculate the number of items available
    DIALOG_ITEMS_COUNT = llGetListLength(items);

    // check to see what the direction was (if one was specified)
    if(direction == BUTTON_BACK)
    {
        // display the previous cycle if the preconditions are met
        if(DIALOG_CYCLE_INDEX > 0)
        {
            // the index can be cycled backward safely
            DIALOG_CYCLE_INDEX--;
        }
    }
    else if(direction == BUTTON_NEXT)
    {
        // display the next cycle if the preconditions are met
        DIALOG_CYCLE_INDEX++;
    }

    // figure out which button cycle needs to be displayed
    if(DIALOG_CYCLE_INDEX == 0) // first cycle
    {
        // check the number of available items
        if(DIALOG_ITEMS_COUNT <= DIALOG_MAX_BUTTONS)
        {
            // the entire list can be displayed as one complete dialog
            sublist = llList2List(items, 0, DIALOG_ITEMS_COUNT - 1);
        }
        else
        {
            // grab the sublist from the beginning until DIALOG_MAX_BUTTONS - 2
            // to take into account the need for a BUTTON_NEXT item
            sublist = llList2List(items, 0, DIALOG_MAX_BUTTONS - 2);

            // append the BUTTON_NEXT item to the end of the cycle
            sublist += [BUTTON_NEXT];
        }
    }
    else // second...n cycle
    {
        // make sure we did not go over the list bounds
        integer start_index = 0;

        // (DIALOG_MAX_BUTTONS - 1) represents the first cycle with the
        // NEXT button
        //
        // ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2)) calculates
        // every cycle after the first (with NEXT and PREV buttons)
        start_index = (DIALOG_MAX_BUTTONS - 1) + ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2));

        // calculate how many items we'll have left after this cycle
        integer items_left = DIALOG_ITEMS_COUNT - start_index;

        // check to see if we'll have another cycle after this one
        if(items_left > DIALOG_MAX_BUTTONS - 2)
        {
            // we can fill another dialog with PREV and NEXT buttons, so
            // this is just another regular cycle (with DIALOG_MAX_BUTTONS - 3) to ensure that
            // the total number of items pulled from SYSTEM_MENU_BUTTONS is actually equal to
            // (DIALOG_MAX_BUTTONS - 2)
            sublist = llList2List(items, start_index, start_index + (DIALOG_MAX_BUTTONS - 3));

            // add the PREV button and NEXT button
            sublist = [BUTTON_BACK] + sublist + [BUTTON_NEXT];
        }
        else
        {
            // we can finish the list along with a PREV button, so this
            // is the final cycle for the list
            sublist = llList2List(items, start_index, DIALOG_ITEMS_COUNT - 1);

            // add the PREV button to the beginning of the cycle
            sublist = [BUTTON_BACK] + sublist;
        }
    }

    // return the generated sublist cycle
	// @todo sort list before next/back buttons are added so they are not sorted into the mix.
    return sort(sublist);
}

integer create_dialog(key id, string message, list buttons)
{
    integer PRIMITIZER_CHANNEL = -((integer)llFrand(8388608))*(255) - (integer)llFrand(8388608) - 11;
    llListenRemove(PRIMITIZER_HANDLE);
    PRIMITIZER_HANDLE = llListen(PRIMITIZER_CHANNEL, "", id, "");
    if(DIALOG_ITEMS_COUNT > 0)
        llDialog(id, message, buttons, PRIMITIZER_CHANNEL);
    else
        llTextBox(id, message, PRIMITIZER_CHANNEL);
    return PRIMITIZER_CHANNEL;
}

clear_dialog()
{
    SYSTEM_MENU_BUTTONS = [];
}

add_dialog(string name, string message, list buttons, list returns, integer timeout)
{
	//
}

// temp function for debug only
link_debugged(integer sender_num, integer num, string str, key id)
{
	string message = "\n" + "sender_num = " + (string)sender_num + "\n";
	message += "num = " + (string)num + "\n";
	message += "str = " + (string)str + "\n";
	message += "id = " + (string)id + "\n";
	llOwnerSay(message);
}

response_dialog(integer sender_num, integer num, string str, key id)
{
	list data = llParseString2List(str, [PRIMITIZER_SEPERATOR], []);
	link_debugged(sender_num, num, str, id);
    if(num == LINK_INTERFACE_DIALOG)
    {
		//
	}
}

request_dialog(integer sender_num, integer num, string str, key id)
{
	list data = llParseString2List(str, [PRIMITIZER_SEPERATOR], []);
	link_debugged(sender_num, num, str, id);
    if(num == LINK_INTERFACE_RESPONSE)
    {
        llOwnerSay("DEBUG:LINK_INTERFACE_RESPONSE");
	}
    else if(num == LINK_INTERFACE_CLEAR)
    {
        llOwnerSay("DEBUG:LINK_INTERFACE_CLEAR");
		clear_dialog();
    }
    else if(num == LINK_INTERFACE_ADD)
    {
		llOwnerSay("DEBUG:LINK_INTERFACE_ADD");
	}
    else if(num == LINK_INTERFACE_SHOW)
    {
		llOwnerSay("DEBUG:LINK_INTERFACE_SHOW");
	}
    else if(num == LINK_INTERFACE_SOUND)
    {
		llOwnerSay("DEBUG:LINK_INTERFACE_SOUND");
	}
}

integer show_dialog(integer link, list buttons, list returns, string name, key id)
{
    if (name != "")
    {
        integer index = llListFindList(buttons, [name]);
        if (index != -1)
        {
            llMessageLinked(LINK_THIS, link, llList2String(returns, index), id); //LINK_INTERFACE_DIALOG
            return TRUE;
        }
        else
        {
            // dialog not found
			llMessageLinked(LINK_THIS, LINK_INTERFACE_NOT_FOUND, name, id);
            return FALSE;
        }
    }
    else
    {
        // dialog name not set
		llMessageLinked(LINK_THIS, LINK_INTERFACE_NOT_FOUND, "", id);
        return FALSE;
    }
}

state Redirect
{
    state_entry()
    {
        if(REDIRECT_STATE == "Dialog") state Dialog;
        else if(REDIRECT_STATE == "Textbox") state Textbox;
        else if(REDIRECT_STATE == "Numeric") state Numeric;
        else state default;
    }
}

default
{
    state_entry()
    {
        // Listen On The Specified Channel And Display Dialog
        // @TODO Remove This Later
        PRIMITIZER_CHANNEL = create_dialog(llGetOwner(), DIALOG_MENU_MESSAGE, pagination(SYSTEM_MENU_BUTTONS, ""));
    }

    changed(integer change)
    {
        // check to see if the object owner changed
        if(change & CHANGED_OWNER)
        {
            // reset the script so calls to llGetOwner()
            // will correctly reference the new owner
            llResetScript();
        }
    }

    link_message(integer sender_num, integer num, string str, key id)
    {
        request_dialog(sender_num, num, str, id);
    }

    listen(integer channel, string name, key id, string message)
    {
		if(channel == PRIMITIZER_CHANNEL)
		{
			if(message == BUTTON_NEXT)
			{
				// user clicked the BUTTON_NEXT option, so get the next
				// cycle of menu items
				PRIMITIZER_CHANNEL = create_dialog(id, DIALOG_MENU_MESSAGE, pagination(SYSTEM_MENU_BUTTONS, BUTTON_NEXT));
				//llSetTimerEvent(timerOut);
			}
			else if(message == BUTTON_BACK)
			{
				// user clicked the BUTTON_BACK option, so get the previous
				// cycle of menu items
				PRIMITIZER_CHANNEL = create_dialog(id, DIALOG_MENU_MESSAGE, pagination(SYSTEM_MENU_BUTTONS, BUTTON_BACK));
				//llSetTimerEvent(timerOut);
			}
			else if(message == " ")
			{
				// user clicked the BUTTON_BACK option, so get the previous
				// cycle of menu items
				PRIMITIZER_CHANNEL = create_dialog(id, DIALOG_MENU_MESSAGE, pagination(SYSTEM_MENU_BUTTONS, ""));
				//llSetTimerEvent(timerOut);
			}
			else
			{
				integer index = llListFindList(SYSTEM_MENU_BUTTONS, [message]);
				llMessageLinked(LINK_THIS, LINK_INTERFACE_RESPONSE, llList2String(SYSTEM_MENU_BUTTONS, index), id);
			}
		}
    }

    touch_start(integer total_number)
    {
        // display the dialog if the owner touched me
        if(llDetectedKey(0) == llGetOwner())
        {
            // display the dialog with the current menu cycle
            PRIMITIZER_CHANNEL = create_dialog(llGetOwner(), DIALOG_MENU_MESSAGE, pagination(SYSTEM_MENU_BUTTONS, ""));
        }
    }
}